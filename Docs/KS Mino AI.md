# KS Mino AI
## AI算法由哪些部分组成？
1. `枚举算法`，列出所有可能的落块情况。枚举多层可以构成一棵树。
2. `评估算法`，评估地形分数，以及落块对分数的影响。
3. `搜索算法`，搜索通过枚举算法得到的树中评分最高的分支。
4. `路径搜索算法`，搜索如何操作能将方块落到正确的位置。

### 枚举算法
- 输入：地形数组、方块种类
- 输出：一个方块列表

### 评估算法
- 输入：地形数组、方块数据
- 输出：分数

### 搜索算法
- 输入：地形、方块数据根节点、深度
- 输出：一个方块数据的序列

### 路径搜索算法
- 输入：地形、方块落点数据
- 输出：一个操作序列（如果用字符表示操作，就是一个字符串）

## 如何完成算法的编写？
### 搭建场景：AI试验场
为了搭建一个高效的AI Debug界面，要重新写一个脚本代替原本的Play.cs。
- 不需要的功能
  - 响应按键操作的“玩家模式”。
  - 玩家模式中的计分板。
  - 消行信息。（反正不是给用户看的）
- 需要的功能
  - 显示地形
  - 地形编辑
  - AI的Debug，比如显示枚举出的方块。

### 编写枚举算法
- BFS
- 去重
  - 中心对称方块I、Z、S需要去重，因为不同旋转状态对地形的影响是一样的。
  - 由于SRS旋转中心的机制，在旋转180度的同时需要进行坐标偏移。

### 编写评估函数
- 加分项
  - 消行
    - Tspin，消四，ren，PC
    - 不是Tspin的消行越多越好，但普通消行分数比上面少
  - 堆叠
    - 地形起伏程度（bumpiness）低
      - 允许地形有一列直列（忽略最深的一列）
      - 忽略T坑所在的列
    - 地形内部的孔洞少
    - 如果有孔洞，孔洞上方的方块越少越好
    - 整体高度不能太高
    - 有T坑或者直列
- 具体实现
  - [ ] 检测T2坑的左下角
  - [ ] 检测T3坑的左下角
  - [x] 在`Field`类中添加表示每列高度的数组`top[col]`
    - [x] 计算bumpiness
  - [x] 编写检测孔洞数量的函数`CountHole()`
### 单块实验

### 多next搜索
- 为了节省时间，采用类似Beam Search的搜索方式，一边搜索一边开树
  - 假设搜索常数为5，每次展开得到的列表都是分数前5的5个
  - 搜索过程
    - 第一层：5个
    - 第二层：对第一层的5个展开，共25个
    - 第三层：取第二层的25个中的前5个展开，共25个
    - 第四层：取第三层的25个中的前5个展开，还是25个
    - 以此类推